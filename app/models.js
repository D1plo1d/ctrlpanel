// Generated by CoffeeScript 1.4.0
var PrintDriver, PrintJob, PrintQueue, config, driver, events, exec, fs, path, rest, temp, yml,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

rest = require('../node_modules/restler/lib/restler');

fs = require('fs');

temp = require('temp');

yml = require('js-yaml');

path = require('path');

exec = require('child_process').exec;

events = require('events');

config = null;

PrintDriver = (function() {

  function PrintDriver() {}

  PrintDriver.prototype.jog = function(opts, callback) {
    var url;
    url = "http://admin:password@localhost:4311/move/axis/" + opts.axis + "/" + opts.distance + "/" + (opts.speed * 60);
    return rest.get(url).on("success", function(data, res) {
      console.log(data);
      return callback();
    });
  };

  return PrintDriver;

})();

PrintQueue = (function() {

  function PrintQueue(d) {
    this.driver = driver;
    this.printJobs = [];
  }

  PrintQueue.prototype.add = function(files, callback) {
    var job,
      _this = this;
    if (true) {
      this.print();
    } else {
      this.printJobs.push(job = new PrintJob(files.path, files.filename));
      job.on("success", function() {
        return _this.print();
      });
    }
    return typeof callback === "function" ? callback() : void 0;
  };

  PrintQueue.prototype.print = function(callback) {
    var data, job, url;
    url = "http://admin:password@localhost:4311/printbutton/";
    if (true) {
      data = {
        filename: "" + __dirname + "/../uploads/68f8e84aee5b44bc39fe6829615a3678.gcode"
      };
    } else {
      job = this.printJobs.pop();
      data = {
        filename: job.gcodePath
      };
      console.log("printing " + job.filename);
    }
    console.log(data);
    return rest.post(url, {
      data: data
    }).on("success", function(data, res) {
      return typeof callback === "function" ? callback() : void 0;
    });
  };

  return PrintQueue;

})();

PrintJob = (function(_super) {

  __extends(PrintJob, _super);

  function PrintJob(cadPath, filename) {
    var _this = this;
    this.cadPath = cadPath;
    this.filename = filename;
    this._onGCodeProcExit = __bind(this._onGCodeProcExit, this);

    this._onConfigLoad = __bind(this._onConfigLoad, this);

    this.status = "slicing";
    fs.readFile("" + __dirname + "/../config/config.yml", "utf8", function(err, data) {
      config = yml.load(data);
      return _this._onConfigLoad();
    });
  }

  PrintJob.prototype._onConfigLoad = function() {
    var extIndex;
    extIndex = this.cadPath.lastIndexOf(path.extname(this.cadPath));
    this.gcodePath = "" + this.cadPath.slice(0, +extIndex + 1 || 9e9) + ".gcode";
    console.log(this.gcodePath);
    this.gcodeProc = exec("export P3D_CAD_FILE=\"" + this.cadPath + "\";\nexport P3D_GCODE_FILE=\"" + this.gcodePath + "\";\n" + config.slicer);
    this.gcodeProc.on('exit', this._onGCodeProcExit);
    this.gcodeProc.stderr.on('data', this._logSlicer);
    return this.gcodeProc.stdout.on('data', this._logSlicer);
  };

  PrintJob.prototype._logSlicer = function(data) {
    var line, _i, _len, _ref, _results;
    _ref = data.split("\n");
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      _results.push(console.log('SLICER > ' + line));
    }
    return _results;
  };

  PrintJob.prototype._onGCodeProcExit = function(slicerExitCode, signal) {
    this.slicerExitCode = slicerExitCode;
    if (this.slicerExitCode === 0) {
      console.log("\n\nGCode Generation Complete");
      this.status = "complete";
      this.emit("success");
    } else {
      console.log("\n\nError Generating GCode");
      this.status = "error";
      this.emit("error");
    }
    return this.emit("complete");
  };

  return PrintJob;

})(events.EventEmitter);

module.exports = {
  driver: (driver = new PrintDriver()),
  queue: new PrintQueue(driver)
};
